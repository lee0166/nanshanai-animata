# 融合方案 - 实施细节与代码示例

## 一、核心Prompt模板库

### 1.1 Pass 1: 全局上下文分析 Prompt

```typescript
const PROMPT_GLOBAL_CONTEXT = `
你是一位资深短剧编剧和故事分析师。请阅读以下小说全文,提取核心信息用于后续影视化改编。

【小说全文】
{novelContent}

【导演设定】(如有)
视觉风格: {visualStyle}
单集时长: {episodeDuration}秒
核心卖点: {sellingPoint}

【输出要求 - 严格JSON格式】
{
  "logline": "一句话故事梗概(30字内,包含主角+冲突+目标)",
  "synopsis": "故事梗概(300字内,包含起承转合)",
  "coreConflicts": [
    {"name": "冲突名称", "description": "冲突描述", "intensity": 8}
  ],
  "emotionalCurve": [
    {"position": "开头", "emotion": "情绪", "intensity": 5}
  ],
  "mainCharacters": [
    {"name": "角色名", "role": "主角/反派/配角", "archetype": "人物原型"}
  ],
  "keyScenes": [
    {"name": "场景名", "importance": 9, "function": "场景功能"}
  ],
  "shortDramaHooks": [
    "黄金3秒钩子1",
    "黄金3秒钩子2"
  ],
  "twistPoints": [
    {"position": "位置", "description": "反转内容"}
  ],
  "recommendedEpisodes": 建议集数,
  "visualStyleGuide": {
    "overall": "整体风格",
    "colorPalette": ["主色调", "辅色调"],
    "lighting": "打光风格",
    "referenceMovies": ["参考电影1", "参考电影2"]
  }
}

【特别要求】
1. coreConflicts必须包含3-5个核心冲突,用于设计黄金3秒
2. shortDramaHooks必须是能抓住观众的冲突/情绪/动作场景
3. twistPoints标记剧情反转点,用于设计每集结尾悬念
4. visualStyleGuide要与导演设定保持一致
`;
```

### 1.2 Pass 2: 角色提取 Prompt

```typescript
const PROMPT_CHARACTER_EXTRACTION = `
请从以下小说片段中提取所有角色信息。

【小说片段】
{chunks}

【全局故事背景】
{globalContext}

【输出要求】
返回角色列表,每个角色包含:
- name: 角色名
- firstAppearance: 首次出现位置
- frequency: 出现频率(high/medium/low)
- roleType: 角色类型(protagonist/antagonist/supporting)

【输出格式 - JSON数组】
[
  {"name": "", "firstAppearance": "", "frequency": "", "roleType": ""}
]
`;
```

### 1.3 Pass 2: 角色深度分析 Prompt

```typescript
const PROMPT_CHARACTER_ANALYSIS = `
你是一位专业角色设计师。请深度分析角色"{characterName}"。

【全局故事背景】
{globalContext}

【角色相关原文】
{retrievedChunks}

【视觉风格】
{visualStyle}

【输出要求 - JSON格式】
{
  "basicInfo": {
    "name": "角色名",
    "age": "年龄(纯数字,如20)",
    "gender": "性别",
    "identity": "身份(20字内)"
  },
  "appearance": {
    "description": "外貌特征(50字内,具体描述发色/眼型/身材)",
    "distinguishingFeatures": ["特征1", "特征2"],
    "height": "身高(如:中等)",
    "build": "体型(如:纤细/健壮)"
  },
  "personality": {
    "traits": ["性格特点1", "性格特点2"],
    "mbti": "MBTI类型(可选)",
    "archetype": "人物原型(如:英雄/导师/反派)"
  },
  "costume": {
    "default": "默认服装(30字内,符合时代背景)",
    "variations": [
      {"scene": "场景", "outfit": "服装变化"}
    ]
  },
  "visualPrompt": {
    "positive": "AI绘画正面提示词(英文,100字内,包含风格关键词)",
    "negative": "负面提示词(英文,如:deformed, bad anatomy)",
    "styleKeywords": ["风格词1", "风格词2"]
  },
  "performance": {
    "style": "表演风格(reserved/expressive/comedic/tragic)",
    "preferredShots": ["close_up", "medium"],
    "lighting": "适合的打光(soft/hard/highContrast)",
    "keyExpressions": ["标志性表情1", "标志性表情2"]
  },
  "storyFunction": {
    "role": "在故事中的作用(主角/反派/导师等)",
    "arc": "人物弧线(如:从自卑到自信)",
    "screenTimeRatio": 戏份占比(0-1),
    "keyMoments": ["关键时刻1", "关键时刻2"]
  },
  "continuity": {
    "consistentElements": ["必须保持一致的元素"],
    "changePoints": [{"when": "何时", "what": "变化内容"}]
  }
}

【特别要求】
1. visualPrompt.positive必须包含:主体+外貌+服装+光影+风格
2. 示例: "A beautiful young Chinese woman, 20 years old, long black hair, wearing traditional Hanfu, soft lighting, cinematic style, 8k, highly detailed"
3. 服装描述要具体到款式/颜色/材质
4. 表演风格影响分镜设计:内敛型多用特写捕捉微表情
`;
```

### 1.4 Pass 3: 分镜生成 Prompt

```typescript
const PROMPT_SHOT_GENERATION = `
你是一位资深短剧导演。请为以下场景设计分镜脚本,严格遵循短剧创作规则。

【短剧核心规则 - 必须遵守】
1. 本集时长: {episodeDuration}秒
2. 镜头数量: {shotCount}个 (每个镜头2-5秒)
3. 黄金3秒: 第1个镜头必须是抓眼球的特写/冲突镜头
4. 每集结构: 钩子(3秒) → 发展(45秒) → 反转(20秒) → 悬念(22秒)
5. 镜头语言:
   - 对话场景: 优先中景(medium),情绪爆发用特写(close_up)
   - 关键道具: 用特写(close_up)
   - 环境渲染: 用远景(long)
6. 运镜规则:
   - 静态对话: 固定(static)
   - 情绪推进: 推镜(push_in)
   - 动作场景: 跟镜(track)
   - 环境展示: 摇镜(pan)

【场景信息】
场景名称: {sceneName}
场景描述: {sceneDescription}
涉及角色: {characters}
在故事中的位置: {positionInStory}
戏剧张力: {dramaticTension}/10

【相关原文】
{relevantChunks}

【故事圣经 - 已确认的角色设定】
{storyBible}

【输出要求 - JSON数组,每个镜头包含】
{
  "sequence": 镜头序号(1-based),
  "shotType": "景别(close_up/medium/long/extreme_long)",
  "cameraMovement": "运镜(static/pan/push_in/track/zoom)",
  "duration": 时长(秒,2-5),
  "description": "画面描述(50字内,具体到人物动作/表情/位置)",
  "dialogue": "台词(如有,精简到核心)",
  "sound": "音效提示(如:心跳声/脚步声)",
  "music": "配乐提示(如:紧张/浪漫)",
  "transition": "转场方式(cut/fade/dissolve/wipe)",
  "focus": "视觉焦点(如:角色的眼睛/手中的刀)",
  "lighting": "打光提示(如:侧光/逆光)",
  "continuityNotes": "连续性注意事项"
}

【分镜设计指导】
- 镜头1(黄金3秒): 必须是特写,展示冲突/情绪/关键道具
- 镜头2-4(发展): 中景为主,推进剧情,展示对话
- 镜头5-6(反转): 情绪爆发,可用推镜加强张力
- 镜头7-8(悬念): 特写结尾,留下悬念(眼神/道具/动作)

【示例输出】
[
  {
    "sequence": 1,
    "shotType": "extreme_close_up",
    "cameraMovement": "static",
    "duration": 3,
    "description": "女主角含泪的眼睛特写,眼神中充满愤怒和不甘",
    "dialogue": "",
    "sound": "心跳声加速",
    "music": "紧张弦乐",
    "transition": "cut",
    "focus": "眼睛",
    "lighting": "侧光,突出眼神",
    "continuityNotes": "眼妆必须一致"
  }
]

【特别要求】
1. 严格按照镜头数量要求生成
2. 每个镜头时长必须在2-5秒范围内
3. 画面描述要具体到可以指导拍摄/生图
4. 台词要精简,短剧以视觉为主
5. 考虑角色服装/道具的连续性
`;
```

---

## 二、核心代码实现

### 2.1 语义分块实现

```typescript
// semantic-chunker.ts
import { LLMProvider } from './llm-provider';

interface ChunkBoundary {
  position: number;
  type: 'chapter' | 'scene' | 'paragraph' | 'sentence';
  confidence: number;
}

interface SemanticChunk {
  id: string;
  content: string;
  prevContext: string;
  boundaries: ChunkBoundary[];
  metadata: {
    characters: string[];
    sceneHint: string;
    importance: number;
    wordCount: number;
  };
}

export class SemanticChunker {
  private llm: LLMProvider;
  
  // 分隔符规则(按优先级排序)
  private readonly SEPARATORS = [
    { pattern: /【第[一二三四五六七八九十百千万]+[章回]】/g, type: 'chapter', weight: 100 },
    { pattern: /\n{2,}/g, type: 'paragraph', weight: 50 },
    { pattern: /[。！？；]/g, type: 'sentence', weight: 20 },
  ];
  
  constructor(llm: LLMProvider) {
    this.llm = llm;
  }
  
  async chunk(content: string, maxTokens: number = 4000): Promise<SemanticChunk[]> {
    // 步骤1: 识别所有潜在分割点
    const boundaries = this.identifyBoundaries(content);
    
    // 步骤2: 使用语义分析优化分割点
    const optimizedBoundaries = await this.optimizeBoundaries(content, boundaries);
    
    // 步骤3: 生成分块
    const chunks = this.createChunks(content, optimizedBoundaries, maxTokens);
    
    // 步骤4: 为每个分块提取元数据
    await this.enrichMetadata(chunks);
    
    // 步骤5: 添加上下文
    this.addContext(chunks);
    
    return chunks;
  }
  
  private identifyBoundaries(content: string): ChunkBoundary[] {
    const boundaries: ChunkBoundary[] = [];
    
    for (const separator of this.SEPARATORS) {
      let match;
      while ((match = separator.pattern.exec(content)) !== null) {
        boundaries.push({
          position: match.index + match[0].length,
          type: separator.type as any,
          confidence: separator.weight
        });
      }
    }
    
    // 按位置排序
    return boundaries.sort((a, b) => a.position - b.position);
  }
  
  private async optimizeBoundaries(
    content: string, 
    boundaries: ChunkBoundary[]
  ): Promise<ChunkBoundary[]> {
    // 使用轻量级模型判断分割点是否合理
    const sampleSize = Math.min(boundaries.length, 20);
    const samples = boundaries.slice(0, sampleSize);
    
    const prompt = `
请判断以下文本分割点是否合理(是否在语义完整的位置)。
分割点前后的文本:
${samples.map((b, i) => `
[分割点${i+1}]
前文: ${content.slice(Math.max(0, b.position - 100), b.position)}
后文: ${content.slice(b.position, b.position + 100)}
`).join('\n')}

请返回JSON数组,每个元素包含index和isReasonable(是否合理的布尔值):
[{"index": 0, "isReasonable": true}, ...]
`;
    
    try {
      const result = await this.llm.generateText(prompt, { maxTokens: 1000 });
      const evaluations = JSON.parse(result);
      
      // 根据评估结果调整置信度
      return boundaries.map((b, i) => {
        const eval_ = evaluations.find((e: any) => e.index === i);
        if (eval_ && !eval_.isReasonable) {
          return { ...b, confidence: b.confidence * 0.5 };
        }
        return b;
      });
    } catch (e) {
      // 如果评估失败,返回原始边界
      return boundaries;
    }
  }
  
  private createChunks(
    content: string, 
    boundaries: ChunkBoundary[], 
    maxTokens: number
  ): SemanticChunk[] {
    const chunks: SemanticChunk[] = [];
    let currentChunk = '';
    let lastBoundary = 0;
    
    // 估算: 1 token ≈ 1.5个中文字符
    const maxChars = maxTokens * 1.5;
    
    for (const boundary of boundaries) {
      const segment = content.slice(lastBoundary, boundary.position);
      
      if ((currentChunk + segment).length > maxChars && currentChunk.length > 0) {
        // 保存当前分块
        chunks.push({
          id: `chunk_${chunks.length}`,
          content: currentChunk.trim(),
          prevContext: '',
          boundaries: [],
          metadata: {
            characters: [],
            sceneHint: '',
            importance: 0,
            wordCount: currentChunk.length
          }
        });
        currentChunk = segment;
      } else {
        currentChunk += segment;
      }
      
      lastBoundary = boundary.position;
    }
    
    // 处理最后一段
    if (currentChunk.length > 0) {
      chunks.push({
        id: `chunk_${chunks.length}`,
        content: currentChunk.trim(),
        prevContext: '',
        boundaries: [],
        metadata: {
          characters: [],
          sceneHint: '',
          importance: 0,
          wordCount: currentChunk.length
        }
      });
    }
    
    return chunks;
  }
  
  private async enrichMetadata(chunks: SemanticChunk[]): Promise<void> {
    // 并行提取每个分块的元数据
    const promises = chunks.map(async (chunk) => {
      const prompt = `
请分析以下文本片段,提取:
1. 涉及的角色名
2. 场景提示(地点/时间)
3. 重要性评分(0-10,冲突/情绪场景分数高)

文本:
${chunk.content.slice(0, 500)}

返回JSON格式:
{
  "characters": ["角色1", "角色2"],
  "sceneHint": "场景描述",
  "importance": 7
}
`;
      
      try {
        const result = await this.llm.generateText(prompt, { maxTokens: 500 });
        const metadata = JSON.parse(result);
        chunk.metadata = { ...chunk.metadata, ...metadata };
      } catch (e) {
        // 提取失败时使用默认值
        chunk.metadata.importance = 5;
      }
    });
    
    await Promise.all(promises);
  }
  
  private addContext(chunks: SemanticChunk[]): void {
    // 为每个分块添加前序上下文
    for (let i = 1; i < chunks.length; i++) {
      const prevChunk = chunks[i - 1];
      const currentChunk = chunks[i];
      
      // 取前500字作为上下文
      currentChunk.prevContext = prevChunk.content.slice(-500);
    }
  }
}
```

### 2.2 RAG检索实现

```typescript
// rag-retriever.ts
import { ChromaClient } from 'chromadb';
import { EmbeddingProvider } from './embedding-provider';

interface RetrievalResult {
  chunk: SemanticChunk;
  similarity: number;
  relevance: number; // 综合相似度和重要性
}

export class RAGRetriever {
  private chroma: ChromaClient;
  private embedding: EmbeddingProvider;
  private collection: any;
  
  constructor(embeddingProvider: EmbeddingProvider) {
    this.chroma = new ChromaClient();
    this.embedding = embeddingProvider;
  }
  
  async initializeCollection(novelId: string): Promise<void> {
    this.collection = await this.chroma.getOrCreateCollection({
      name: `novel_${novelId}`,
      metadata: { description: '小说语义分块向量库' }
    });
  }
  
  async indexChunks(chunks: SemanticChunk[]): Promise<void> {
    const ids = chunks.map(c => c.id);
    const documents = chunks.map(c => c.content);
    const embeddings = await this.embedding.embedBatch(documents);
    const metadatas = chunks.map(c => ({
      characters: c.metadata.characters.join(','),
      sceneHint: c.metadata.sceneHint,
      importance: c.metadata.importance,
      wordCount: c.metadata.wordCount
    }));
    
    await this.collection.add({
      ids,
      documents,
      embeddings,
      metadatas
    });
  }
  
  async retrieve(
    query: string, 
    options: {
      topK?: number;
      characterFilter?: string[];
      minImportance?: number;
    } = {}
  ): Promise<RetrievalResult[]> {
    const { topK = 5, characterFilter, minImportance = 0 } = options;
    
    // 生成查询向量
    const queryEmbedding = await this.embedding.embed(query);
    
    // 构建过滤条件
    const where: any = {};
    if (minImportance > 0) {
      where.importance = { $gte: minImportance };
    }
    if (characterFilter && characterFilter.length > 0) {
      where.characters = { $in: characterFilter };
    }
    
    // 执行检索
    const results = await this.collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: topK * 2, // 多取一些用于后续排序
      where: Object.keys(where).length > 0 ? where : undefined
    });
    
    // 综合排序(相似度 + 重要性)
    const retrievalResults: RetrievalResult[] = results.ids[0].map((id: string, idx: number) => {
      const similarity = results.distances[0][idx];
      const metadata = results.metadatas[0][idx];
      const importance = metadata.importance || 5;
      
      // 综合得分: 相似度 * (重要性 / 10)
      const relevance = similarity * (importance / 10);
      
      return {
        chunk: {
          id,
          content: results.documents[0][idx],
          prevContext: '',
          boundaries: [],
          metadata
        } as SemanticChunk,
        similarity,
        relevance
      };
    });
    
    // 按综合相关性排序,取topK
    return retrievalResults
      .sort((a, b) => b.relevance - a.relevance)
      .slice(0, topK);
  }
  
  // 针对角色的专门检索
  async retrieveForCharacter(
    characterName: string,
    topK: number = 10
  ): Promise<RetrievalResult[]> {
    // 构建角色相关查询
    const query = `${characterName} 的出场 外貌 服装 动作 对话 情绪`;
    
    return this.retrieve(query, {
      topK,
      characterFilter: [characterName],
      minImportance: 3
    });
  }
  
  // 针对场景的专门检索
  async retrieveForScene(
    sceneName: string,
    sceneHint: string,
    topK: number = 8
  ): Promise<RetrievalResult[]> {
    const query = `${sceneName} ${sceneHint} 环境 地点 时间 氛围`;
    
    return this.retrieve(query, {
      topK,
      minImportance: 4
    });
  }
}
```

### 2.3 模型路由实现

```typescript
// model-router.ts
import { LLMProvider } from './llm-provider';

interface ModelConfig {
  name: string;
  provider: string;
  maxTokens: number;
  contextWindow: number;
  costPer1KInput: number;
  costPer1KOutput: number;
  strengths: string[];
  rateLimit: number; // requests per minute
}

interface RoutingDecision {
  model: string;
  estimatedCost: number;
  estimatedTime: number;
  fallbackChain: string[];
}

const AVAILABLE_MODELS: Record<string, ModelConfig> = {
  'kimi': {
    name: 'kimi',
    provider: 'moonshot',
    maxTokens: 8000,
    contextWindow: 200000,
    costPer1KInput: 0.012,
    costPer1KOutput: 0.012,
    strengths: ['long_context', 'chinese', 'creative'],
    rateLimit: 10
  },
  'gpt-4o': {
    name: 'gpt-4o',
    provider: 'openai',
    maxTokens: 4000,
    contextWindow: 128000,
    costPer1KInput: 0.005,
    costPer1KOutput: 0.015,
    strengths: ['creative', 'instruction_following', 'json'],
    rateLimit: 20
  },
  'gpt-4o-mini': {
    name: 'gpt-4o-mini',
    provider: 'openai',
    maxTokens: 4000,
    contextWindow: 128000,
    costPer1KInput: 0.00015,
    costPer1KOutput: 0.0006,
    strengths: ['fast', 'cheap', 'simple_tasks'],
    rateLimit: 100
  },
  'deepseek-v2': {
    name: 'deepseek-v2',
    provider: 'deepseek',
    maxTokens: 4000,
    contextWindow: 32000,
    costPer1KInput: 0.0005,
    costPer1KOutput: 0.0015,
    strengths: ['chinese', 'cheap', 'coding'],
    rateLimit: 30
  },
  'claude-3-sonnet': {
    name: 'claude-3-sonnet',
    provider: 'anthropic',
    maxTokens: 4000,
    contextWindow: 200000,
    costPer1KInput: 0.003,
    costPer1KOutput: 0.015,
    strengths: ['creative', 'nuanced', 'long_context'],
    rateLimit: 15
  }
};

const TASK_MODEL_MAPPING: Record<string, { primary: string; fallbacks: string[] }> = {
  'global_summary': { primary: 'kimi', fallbacks: ['claude-3-sonnet', 'gpt-4o'] },
  'entity_extraction': { primary: 'gpt-4o-mini', fallbacks: ['deepseek-v2'] },
  'character_analysis': { primary: 'gpt-4o', fallbacks: ['kimi', 'claude-3-sonnet'] },
  'scene_analysis': { primary: 'gpt-4o', fallbacks: ['kimi', 'deepseek-v2'] },
  'shot_generation': { primary: 'gpt-4o', fallbacks: ['claude-3-sonnet', 'kimi'] },
  'validation': { primary: 'gpt-4o-mini', fallbacks: ['deepseek-v2'] }
};

export class ModelRouter {
  private providers: Map<string, LLMProvider>;
  private rateLimiters: Map<string, RateLimiter>;
  
  constructor() {
    this.providers = new Map();
    this.rateLimiters = new Map();
    
    // 初始化各模型提供商
    for (const [name, config] of Object.entries(AVAILABLE_MODELS)) {
      this.providers.set(name, this.createProvider(config));
      this.rateLimiters.set(name, new RateLimiter(config.rateLimit));
    }
  }
  
  private createProvider(config: ModelConfig): LLMProvider {
    // 根据提供商创建对应的实例
    switch (config.provider) {
      case 'moonshot':
        return new KimiProvider(config);
      case 'openai':
        return new OpenAIProvider(config);
      case 'deepseek':
        return new DeepSeekProvider(config);
      case 'anthropic':
        return new AnthropicProvider(config);
      default:
        throw new Error(`Unknown provider: ${config.provider}`);
    }
  }
  
  async routeAndExecute(
    taskType: string,
    prompt: string,
    options: {
      maxTokens?: number;
      temperature?: number;
      requireJson?: boolean;
    } = {}
  ): Promise<{
    content: string;
    modelUsed: string;
    tokensUsed: { input: number; output: number };
    cost: number;
    latency: number;
  }> {
    const routing = TASK_MODEL_MAPPING[taskType];
    if (!routing) {
      throw new Error(`Unknown task type: ${taskType}`);
    }
    
    const modelChain = [routing.primary, ...routing.fallbacks];
    const startTime = Date.now();
    
    for (const modelName of modelChain) {
      try {
        // 检查限流
        const rateLimiter = this.rateLimiters.get(modelName)!;
        await rateLimiter.acquire();
        
        // 获取提供商
        const provider = this.providers.get(modelName)!;
        const config = AVAILABLE_MODELS[modelName];
        
        // 执行调用
        const result = await provider.generateText(prompt, {
          maxTokens: options.maxTokens || config.maxTokens,
          temperature: options.temperature ?? 0.7
        });
        
        // 计算成本
        const inputTokens = this.estimateTokens(prompt);
        const outputTokens = this.estimateTokens(result);
        const cost = (inputTokens / 1000) * config.costPer1KInput + 
                     (outputTokens / 1000) * config.costPer1KOutput;
        
        // 如果需要JSON,进行验证
        if (options.requireJson) {
          const validated = this.validateAndFixJson(result);
          if (!validated) {
            throw new Error('JSON validation failed');
          }
        }
        
        return {
          content: result,
          modelUsed: modelName,
          tokensUsed: { input: inputTokens, output: outputTokens },
          cost,
          latency: Date.now() - startTime
        };
        
      } catch (error) {
        console.warn(`Model ${modelName} failed for task ${taskType}:`, error);
        // 继续尝试下一个模型
        continue;
      }
    }
    
    throw new Error(`All models failed for task ${taskType}`);
  }
  
  private estimateTokens(text: string): number {
    // 简单估算: 中文字符 ≈ 1 token, 英文单词 ≈ 1.3 tokens
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
    return Math.ceil(chineseChars + englishWords * 1.3);
  }
  
  private validateAndFixJson(content: string): string | null {
    try {
      // 尝试直接解析
      JSON.parse(content);
      return content;
    } catch (e) {
      // 尝试提取JSON部分
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          JSON.parse(jsonMatch[0]);
          return jsonMatch[0];
        } catch (e2) {
          return null;
        }
      }
      return null;
    }
  }
  
  // 获取路由决策(用于预估)
  getRoutingDecision(taskType: string, promptLength: number): RoutingDecision {
    const routing = TASK_MODEL_MAPPING[taskType];
    const model = AVAILABLE_MODELS[routing.primary];
    
    const estimatedInputTokens = this.estimateTokens('x'.repeat(promptLength));
    const estimatedOutputTokens = model.maxTokens * 0.5; // 假设输出为最大的一半
    
    const cost = (estimatedInputTokens / 1000) * model.costPer1KInput + 
                 (estimatedOutputTokens / 1000) * model.costPer1KOutput;
    
    return {
      model: routing.primary,
      estimatedCost: cost,
      estimatedTime: 5000, // 假设5秒
      fallbackChain: routing.fallbacks
    };
  }
}

// 简单限流器
class RateLimiter {
  private tokens: number;
  private lastRefill: number;
  
  constructor(private maxTokens: number) {
    this.tokens = maxTokens;
    this.lastRefill = Date.now();
  }
  
  async acquire(): Promise<void> {
    this.refill();
    
    if (this.tokens >= 1) {
      this.tokens--;
      return;
    }
    
    // 等待下一个token
    const waitTime = (60000 / this.maxTokens);
    await new Promise(resolve => setTimeout(resolve, waitTime));
    return this.acquire();
  }
  
  private refill(): void {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    const tokensToAdd = (elapsed / 60000) * this.maxTokens;
    
    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}
```

### 2.4 短剧规则引擎实现

```typescript
// short-drama-rules.ts

interface ShortDramaConfig {
  episodeDuration: number;      // 单集时长(秒)
  shotsPerEpisode: number;      // 每集镜头数
  shotDurationRange: [number, number]; // 单镜头时长范围
}

interface EpisodeStructure {
  hook: { duration: number; shots: number; };
  development: { duration: number; shots: number; };
  twist: { duration: number; shots: number; };
  suspense: { duration: number; shots: number; };
}

interface ShotRule {
  shotType: string;
  cameraMovement: string;
  duration: number;
  applicable: string[]; // 适用场景
}

// 短剧规则配置
const DEFAULT_SHORT_DRAMA_CONFIG: ShortDramaConfig = {
  episodeDuration: 90,  // 默认90秒
  shotsPerEpisode: 7,   // 7个镜头
  shotDurationRange: [2, 5] // 2-5秒/镜
};

// 标准短剧结构 (90秒 = 3秒钩子 + 45秒发展 + 20秒反转 + 22秒悬念)
const EPISODE_STRUCTURE_90S: EpisodeStructure = {
  hook: { duration: 3, shots: 1 },
  development: { duration: 45, shots: 3 },
  twist: { duration: 20, shots: 2 },
  suspense: { duration: 22, shots: 1 }
};

// 镜头类型规则
const SHOT_TYPE_RULES: Record<string, ShotRule[]> = {
  hook: [
    { shotType: 'extreme_close_up', cameraMovement: 'static', duration: 3, applicable: ['emotion', 'prop', 'conflict'] },
    { shotType: 'close_up', cameraMovement: 'push_in', duration: 3, applicable: ['emotion', 'action'] }
  ],
  development: [
    { shotType: 'medium', cameraMovement: 'static', duration: 4, applicable: ['dialogue', 'interaction'] },
    { shotType: 'medium_close_up', cameraMovement: 'pan', duration: 3, applicable: ['dialogue', 'emotion'] }
  ],
  twist: [
    { shotType: 'close_up', cameraMovement: 'push_in', duration: 3, applicable: ['emotion_burst', 'reveal'] },
    { shotType: 'medium', cameraMovement: 'track', duration: 4, applicable: ['action', 'chase'] }
  ],
  suspense: [
    { shotType: 'extreme_close_up', cameraMovement: 'static', duration: 4, applicable: ['prop', 'eyes', 'hands'] },
    { shotType: 'close_up', cameraMovement: 'static', duration: 3, applicable: ['expression', 'reaction'] }
  ]
};

export class ShortDramaRulesEngine {
  private config: ShortDramaConfig;
  
  constructor(config: Partial<ShortDramaConfig> = {}) {
    this.config = { ...DEFAULT_SHORT_DRAMA_CONFIG, ...config };
  }
  
  // 根据时长获取集数结构
  getEpisodeStructure(): EpisodeStructure {
    const ratio = this.config.episodeDuration / 90;
    
    return {
      hook: {
        duration: Math.round(3 * ratio),
        shots: 1
      },
      development: {
        duration: Math.round(45 * ratio),
        shots: Math.round(3 * ratio)
      },
      twist: {
        duration: Math.round(20 * ratio),
        shots: Math.round(2 * ratio)
      },
      suspense: {
        duration: Math.round(22 * ratio),
        shots: Math.max(1, Math.round(1 * ratio))
      }
    };
  }
  
  // 获取某部分的镜头规则
  getShotRulesForSection(section: keyof EpisodeStructure): ShotRule[] {
    return SHOT_TYPE_RULES[section] || SHOT_TYPE_RULES.development;
  }
  
  // 验证分镜是否符合规则
  validateShots(shots: any[]): { valid: boolean; issues: string[] } {
    const issues: string[] = [];
    const structure = this.getEpisodeStructure();
    
    // 检查镜头总数
    const totalShots = structure.hook.shots + structure.development.shots + 
                       structure.twist.shots + structure.suspense.shots;
    if (shots.length !== totalShots) {
      issues.push(`镜头数量错误: 期望${totalShots}个,实际${shots.length}个`);
    }
    
    // 检查总时长
    const totalDuration = shots.reduce((sum, s) => sum + s.duration, 0);
    if (Math.abs(totalDuration - this.config.episodeDuration) > 5) {
      issues.push(`总时长错误: 期望${this.config.episodeDuration}秒,实际${totalDuration}秒`);
    }
    
    // 检查每个镜头时长
    shots.forEach((shot, idx) => {
      if (shot.duration < this.config.shotDurationRange[0]) {
        issues.push(`镜头${idx+1}时长过短: ${shot.duration}秒`);
      }
      if (shot.duration > this.config.shotDurationRange[1]) {
        issues.push(`镜头${idx+1}时长过长: ${shot.duration}秒`);
      }
    });
    
    // 检查黄金3秒
    if (shots.length > 0) {
      const firstShot = shots[0];
      if (firstShot.duration > 3) {
        issues.push('黄金3秒镜头时长超过3秒');
      }
      if (!['close_up', 'extreme_close_up'].includes(firstShot.shotType)) {
        issues.push('黄金3秒镜头必须是特写');
      }
    }
    
    return {
      valid: issues.length === 0,
      issues
    };
  }
  
  // 自动修复分镜
  autoFixShots(shots: any[]): any[] {
    const fixed = [...shots];
    const structure = this.getEpisodeStructure();
    
    // 确保镜头数量正确
    const targetShots = structure.hook.shots + structure.development.shots + 
                        structure.twist.shots + structure.suspense.shots;
    
    if (fixed.length < targetShots) {
      // 补充镜头
      while (fixed.length < targetShots) {
        fixed.push({
          sequence: fixed.length + 1,
          shotType: 'medium',
          cameraMovement: 'static',
          duration: 3,
          description: '补充镜头',
          dialogue: '',
          sound: '',
          transition: 'cut'
        });
      }
    } else if (fixed.length > targetShots) {
      // 删减镜头(保留重要的)
      fixed.splice(targetShots);
    }
    
    // 调整时长
    const currentDuration = fixed.reduce((sum, s) => sum + s.duration, 0);
    const ratio = this.config.episodeDuration / currentDuration;
    
    fixed.forEach(shot => {
      shot.duration = Math.round(shot.duration * ratio);
      // 确保在范围内
      shot.duration = Math.max(
        this.config.shotDurationRange[0],
        Math.min(this.config.shotDurationRange[1], shot.duration)
      );
    });
    
    // 确保第一个镜头符合黄金3秒
    if (fixed.length > 0) {
      fixed[0].duration = 3;
      fixed[0].shotType = 'extreme_close_up';
      fixed[0].cameraMovement = 'static';
    }
    
    return fixed;
  }
  
  // 生成Prompt增强指令
  generatePromptEnhancement(): string {
    const structure = this.getEpisodeStructure();
    
    return `
【短剧规则 - 必须严格遵守】
1. 本集总时长: ${this.config.episodeDuration}秒
2. 镜头总数: ${this.config.shotsPerEpisode}个
3. 单镜头时长: ${this.config.shotDurationRange[0]}-${this.config.shotDurationRange[1]}秒
4. 黄金3秒: 第1个镜头必须是特写,时长3秒,抓人眼球
5. 集数结构:
   - 钩子(Hook): ${structure.hook.duration}秒, ${structure.hook.shots}个镜头
   - 发展(Development): ${structure.development.duration}秒, ${structure.development.shots}个镜头
   - 反转(Twist): ${structure.twist.duration}秒, ${structure.twist.shots}个镜头
   - 悬念(Suspense): ${structure.suspense.duration}秒, ${structure.suspense.shots}个镜头
6. 镜头语言:
   - 对话场景: 优先中景(medium)
   - 情绪爆发: 用特写(close_up) + 推镜(push_in)
   - 关键道具: 用特写(close_up)
   - 动作场景: 用跟镜(track)
`;
  }
}
```

---

## 三、实施检查清单

### Phase 1 检查清单

- [ ] 语义分块模块单元测试通过率 > 95%
- [ ] 向量数据库部署完成(Chroma/Milvus)
- [ ] 多级缓存系统Redis集成完成
- [ ] 模型路由框架支持至少3个模型
- [ ] 细粒度状态管理数据库表设计完成
- [ ] 基础Prompt v2版本编写完成

### Phase 2 检查清单

- [ ] 集数拆分算法准确率 > 90%
- [ ] 黄金3秒规则引擎实现
- [ ] 分镜规则引擎支持自定义配置
- [ ] 镜头语言库包含10+种景别/运镜
- [ ] 节奏分析模块能识别爽点/泪点

### Phase 3 检查清单

- [ ] 人工确认UI原型设计完成
- [ ] 故事圣经锁定机制实现
- [ ] 资产相似度匹配准确率 > 70%
- [ ] 资产映射UI支持拖拽调整

### Phase 4 检查清单

- [ ] JSON自动修复成功率 > 95%
- [ ] 指数退避重试策略实现
- [ ] 多模型降级策略测试通过
- [ ] 任务队列(Redis+BullMQ)部署
- [ ] 监控面板包含关键指标

---

## 四、测试用例示例

### 4.1 语义分块测试

```typescript
// 测试用例1: 章节边界识别
const novelWithChapters = `
【第一章】初遇
林黛玉走进大观园...

【第二章】相识
宝玉第一次见到黛玉...
`;

const chunks = await chunker.chunk(novelWithChapters);
expect(chunks.length).toBe(2);
expect(chunks[0].content).toContain('第一章');

// 测试用例2: 上下文传递
const longNovel = '...'; // 长文本
const chunks = await chunker.chunk(longNovel);
for (let i = 1; i < chunks.length; i++) {
  expect(chunks[i].prevContext.length).toBeGreaterThan(0);
}
```

### 4.2 RAG检索测试

```typescript
// 测试用例: 角色检索
const results = await retriever.retrieveForCharacter('林黛玉', 5);
expect(results.length).toBe(5);
expect(results[0].chunk.metadata.characters).toContain('林黛玉');
expect(results[0].relevance).toBeGreaterThan(0.5);
```

### 4.3 模型路由测试

```typescript
// 测试用例: 任务路由
const result = await router.routeAndExecute('entity_extraction', prompt);
expect(result.modelUsed).toBe('gpt-4o-mini');
expect(result.cost).toBeLessThan(0.001);

// 测试用例: 降级策略
// 模拟gpt-4o-mini失败
const result2 = await router.routeAndExecute('entity_extraction', prompt);
expect(['deepseek-v2', 'gpt-4o-mini']).toContain(result2.modelUsed);
```

### 4.4 短剧规则测试

```typescript
// 测试用例: 分镜验证
const invalidShots = [
  { sequence: 1, shotType: 'long', duration: 5 }, // 黄金3秒错误
  { sequence: 2, shotType: 'medium', duration: 10 } // 时长过长
];

const validation = rulesEngine.validateShots(invalidShots);
expect(validation.valid).toBe(false);
expect(validation.issues.length).toBeGreaterThan(0);

// 测试用例: 自动修复
const fixed = rulesEngine.autoFixShots(invalidShots);
const validation2 = rulesEngine.validateShots(fixed);
expect(validation2.valid).toBe(true);
```

---

## 五、部署架构建议

```
┌─────────────────────────────────────────────────────────────┐
│                        负载均衡器 (Nginx)                    │
└───────────────────────────────────┬─────────────────────────┘
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                      API 服务集群 (Node.js)                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Instance 1 │  │  Instance 2 │  │  Instance 3 │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└───────────────────────────────────┬─────────────────────────┘
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                      任务队列 (Redis + BullMQ)               │
└───────────────────────────────────┬─────────────────────────┘
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                    Worker 集群 (解析服务)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Worker 1   │  │  Worker 2   │  │  Worker 3   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└───────────────────────────────────┬─────────────────────────┘
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据层                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ PostgreSQL  │  │  Redis      │  │  ChromaDB   │         │
│  │ (状态/业务) │  │  (缓存/队列)│  │  (向量库)   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

---

## 六、监控指标

### 6.1 技术指标

| 指标 | 目标值 | 告警阈值 |
|------|--------|----------|
| 解析成功率 | > 99% | < 95% |
| 平均解析时间 | < 8分钟 | > 15分钟 |
| LLM调用成功率 | > 98% | < 95% |
| 缓存命中率 | > 60% | < 40% |
| API响应时间(P99) | < 500ms | > 1s |

### 6.2 业务指标

| 指标 | 目标值 | 测量方式 |
|------|--------|----------|
| 角色一致性 | > 95% | 导演评分 |
| 分镜短剧化程度 | > 90% | 规则引擎验证 |
| 资产复用率 | > 60% | 系统统计 |
| 导演满意度 | > 85% | 问卷调查 |

---

## 七、附录: Prompt版本管理

建议建立Prompt版本管理系统:

```typescript
interface PromptVersion {
  id: string;
  name: string;
  version: string;
  content: string;
  variables: string[];
  model: string;
  temperature: number;
  maxTokens: number;
  testCases: TestCase[];
  performance: {
    successRate: number;
    avgLatency: number;
    avgCost: number;
  };
  createdAt: Date;
  updatedAt: Date;
}

// Prompt A/B测试
async function runPromptABTest(
  versionA: PromptVersion,
  versionB: PromptVersion,
  testCases: TestCase[]
): Promise<ABTestResult> {
  // 实现A/B测试逻辑
}
```

---

**文档版本**: v1.0  
**最后更新**: 2024年  
**维护者**: AI工程团队
